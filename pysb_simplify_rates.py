import pysb.bng
import sympy as sp
import sys
from sympy.printing import latex
import re
import numpy as np
import tabulate as tb
import pandas as pd
import collections

"""READ BEFORE USAGE
The purpose of this module is to show side-by-side comparisons of simplified rates generated by pysb modules. The main function in this module is:
    main_print_rates(model_list) 
It takes as input a list of pysb models, for which EQUATIONS HAVE ALREADY BEEN GENERATED. From this, it prints to standard output two tables: 
    1. mapping species names to their identities within pysb eg __s0 --> B(d=None, i=1) % I(b=1)
    2. the reaction schema and its corresponding k_f, k_r and k_d (simplified as per the best that psyb can do)
    
These tables can optionally be generated using plaintext OR in latex format for later visualization.

Example:
    
    import kholodenko_m1 as m
    pysb.bng.generate_equations(m.model)
    main_print_rates([m.model])
    
Prints to std.out:

__s0  B(d=None, i=None)
__s1  I(b=None)
__s2  B(d=1, i=None) % B(d=1, i=None)
__s3  B(d=None, i=1) % I(b=1)
__s4  B(d=1, i=2) % B(d=1, i=None) % I(b=2)
__s5  B(d=1, i=2) % B(d=1, i=3) % I(b=2) % I(b=3)
----  -------------------------------------------
-------------  ---------------------------------------------------------------------------------  ------------------------------------------  ----------------------------------------  ---------------------------------------------
kholodenko-m1  B(d=None, i=1)I(b=1) + B(d=None, i=1)I(b=1)<-->B(d=1, i=2)B(d=1, i=3)I(b=2)I(b=3)  0.5*__s3**2*(f**(-1)*g**(-1))**phi*k_on_BB  __s5*(f**(-1)*g**(-1))**phi*f*g*k_off_BB  2.0*__s5*k_on_BB**(-1)*f*g*k_off_BB/__s3**2
kholodenko-m1  B(d=None, i=None) + B(d=None, i=1)I(b=1)<-->B(d=1, i=2)B(d=1, i=None)I(b=2)        __s0*__s3*f**(-phi)*k_on_BB                 __s4*f**(1 - phi)*k_off_BB                __s4*k_on_BB**(-1)*f*k_off_BB/(__s0*__s3)
kholodenko-m1  B(d=None, i=None) + B(d=None, i=None)<-->B(d=1, i=None)B(d=1, i=None)              0.5*__s0**2*k_on_BB                         __s2*k_off_BB                             2.0*__s2*k_on_BB**(-1)*k_off_BB/__s0**2
kholodenko-m1  B(d=None, i=None) + I(b=None)<-->B(d=None, i=1)I(b=1)                              __s0*__s1*k_on_BI                           __s3*k_off_BI                             __s3*k_on_BI**(-1)*k_off_BI/(__s0*__s1)
kholodenko-m1  I(b=None) + B(d=1, i=2)B(d=1, i=None)I(b=2)<-->B(d=1, i=2)B(d=1, i=3)I(b=2)I(b=3)  __s1*__s4*g**(-phi)*k_on_BI                 2.0*__s5*g**(-phi)*g*k_off_BI             2.0*__s5*k_on_BI**(-1)*g*k_off_BI/(__s1*__s4)
kholodenko-m1  I(b=None) + B(d=1, i=None)B(d=1, i=None)<-->B(d=1, i=2)B(d=1, i=None)I(b=2)        2.0*__s1*__s2*f**(-phi)*k_on_BI             __s4*f**(1 - phi)*k_off_BI                0.5*__s4*k_on_BI**(-1)*f*k_off_BI/(__s1*__s2)
-------------  ---------------------------------------------------------------------------------  ------------------------------------------  ----------------------------------------  -------------------------------------------------  -------------------------------------------

"""


def fmt_rct(r, species_dict, fmt='plain'):
    """Formats a given reaction from pysb to a given output format.
    
    Arguments:
        r : collections.namedtuple reaction object
        species_dict : mapping of pysb species names present in expressions to the actual species eg __s0 --> B(...)
        fmt: string format to output. current options are
                'plain': plaintext
                'latex': latex
        TODO: implement the species_dict mapping
    
    Returns:
        List of strings [reaction_name, reaction_schema, k_f, k_r, k_d]
    """
    arrow = {'latex': " $\longleftrightarrow$ ",
             'plain': "<-->"}[fmt]
    fmt_fct = {'latex': lambda x: "$%s$" % latex(x).replace("__", "").replace(" % ", ""),
               'plain': lambda x: str(x).replace(" % ", "")}[fmt]
    r_schema = " + ".join(map(fmt_fct, r.reactants)) + arrow + "".join(map(fmt_fct, r.products))
    return [r.name.replace("_", "-"), r_schema, fmt_fct(r.fwd_rate), fmt_fct(r.rev_rate), fmt_fct(r.kd)]


def gen_table(model, fmt='plain'):
    """Generates a tidy pandas DataFrame of reaction rates for all bidirectional reactions 
    
    Arguments:
        model: pysb model
    
    Returns:
          table_mapping_species_to_internal_naming, all_rates_tidy_df
          all_rates_tidy_df includes all bidirectional reactions, each row corresponds to a single bidirectional reaction
          Columns are labeled:
                   ["model", "name", "schema", "fwd_rate", "rev_rate", "kd"]
                   model: name of model
                   name: rule name for the reaction
                   schema: react1 + react2 + ... <--> prod1 + prod2 + ...
                   fwd_rate
                   rev_rate
                   kd
    """
    # this is assuming that all models must have the same species....
    m = model
    species_dict = dict([('__s%d' % idx, str(m.species[idx])) for idx in range(len(m.species))])
    
    all_rates_tidy = pd.DataFrame(data=np.vstack([[model_name(m)] \
                                                   + fmt_rct(x, species_dict, fmt=fmt) \
                                                   for x in gen_rct_rates(m)]), \
                                columns=["model", "name", "schema", "fwd_rate", "rev_rate", "kd"])

    return np.array(sorted(species_dict.items(), key = lambda x:x[0])),  all_rates_tidy.sort_values(["schema"])
        
def gen_rct_rates(m):
    """From a model, generate k_f, k_r, k_d for all bidirectional reactions.
    
    Arguments:
        model: a pysb model
        
    Returns:
        A list of ReactionTuples, which are namedtuple objects with the fields: 
                ["name", "reactants", "products", "fwd_rate", "rev_rate", "kd"]
    """
    ## from a model, create a generator of all reaction rates binned by forward, reverse, kd
  
    rct_subs = dict(zip(m.expressions,[e.expand_expr(expand_observables=True) for e in m.expressions])) #\+ [(sp.Symbol('__s%d' % m.get_species_index(complex_pattern=species)), latex(species)) for species in m.species])
    species_map = dict(zip(range(len(m.species)), m.species))
    species = lambda tup: [species_map[x] for x in tup]
    
    fwd_rxn = dict([((r["rule"][0], r["products"], r["reactants"]), r) for r in m.reactions if not r["reverse"][0]])
    rev_rxn = dict([((r["rule"][0], r["reactants"], r["products"]), r) for r in m.reactions if r["reverse"][0]])
    rxn_tup = collections.namedtuple("reaction", ["name", "reactants", "products", "fwd_rate", "rev_rate", "kd"])
    rxn_ids = fwd_rxn.keys()
    
    def make_rct_tuple(rxn_id):
        
        rule_name = rxn_id[0]
        try:
            rev_rate = extra_simple(rev_rxn[rxn_id]["rate"].subs(rct_subs))
        except:
            rev_rate = 'Irreversible' # reverse rxn never happens
           
            
        fwd_rate = extra_simple(fwd_rxn[rxn_id]["rate"].subs(rct_subs))
        
        if rev_rate != 'Irreversible': 
            kd = extra_simple(rev_rate/fwd_rate)
        
        else:
             kd = 'Irreversible'
        
        reactants, products = [species(fwd_rxn[rxn_id][s]) for s in ["reactants", "products"]]

        return rxn_tup(rule_name, reactants, products, fwd_rate, rev_rate, kd)
    
    return map(make_rct_tuple, rxn_ids)

    
def table_to_printstream(species, table, fmt='plain'):
    """Given species table and reaction table get properly formatted output.
    
    Arguments:
        species: table of species as output by gen_table
        table: rxn table as returned by gen_table
    
    Returns:
        string formatted output
    """
    table = table.sort_values("model")
    table = table[["model", "schema", "fwd_rate", "rev_rate", "kd"]].as_matrix()
    
    if fmt == 'latex':
        return "\n".join(["\documentclass{article}",
                             "\usepackage[utf8]{inputenc}", 
                             "\usepackage{amsmath}", 
                             "\\begin{document}", 
                            '\def\\arraystretch{2}',
                          tb.tabulate(species, tablefmt='latex_raw'),
                          tb.tabulate(table, tablefmt='latex_raw'),
                          "\end{document}"])
    elif fmt == 'plain':
        return "\n".join([tb.tabulate(species),
                          tb.tabulate(table)])
    
# Helper Functions
def extra_simple(mul):
    """Simplification of pysb rates
    
    Arguments:
        mul: psyb reaction (sympy.Mul object)
    
    Returns:
        a simplified version denested of exponents. 
        TODO: make sure it fully simplifies!
    """
    return sp.powsimp((sp.expand_power_base(sp.powdenest(sp.logcombine(sp.expand_log(mul.simplify(), force=True), force=True), force=True), force=True)), force=True)

def model_name(model):
    """Helper function to access the model name and reformat for the visualized output (no underscores)."""
    return model.name.replace("_", "-")

# Main Function
def main_print_rates(models):
    species_rxns_list = [gen_table(model, fmt='plain') for model in models]
    [sys.stdout.write(table_to_printstream(species, rxns, fmt='plain')) for species, rxns in species_rxns_list]

